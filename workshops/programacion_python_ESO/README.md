# [Programación con Python para estudiantes de ESO](https://github.com/vicente-gonzalez-ruiz/YAPT/tree/master/workshops/programacion_python_ESO#programaci%C3%B3n-con-python-para-estudiantes-de-eso)

## ¿Por qué podría sernos útil saber programar?

Porque:

1. [Puede ser divertido](https://www.fluentu.com/blog/english-esp/wp-content/uploads/sites/33/2018/04/online-games-to-practice-english-e1522729897682.jpg).
2. [Puede ser útil](https://es.euronews.com/2020/06/08/superordenadores-contra-el-coronavirus-identifican-moleculas-que-bloquean-su-progresion).
3. [Puedes ganarte la vida con ello](https://www.revistagq.com/noticias/articulo/trabajos-mas-demandados-2020).

## ¿En qué vamos a programar?

Usaremos el lenguaje de programación [Python](https://www.python.org/)
por ser:
1. [Fácil de
   aprender](https://programadesdecero.com/lenguaje-programacion-aprender/)
   (básicamente, se diseñó con la idea de parecerse al lenguaje
   natural Inglés).
2. [Libre](https://empresas.blogthinkbig.com/las-5-razones-por-las-que-todo-el-mundo-quiere-aprender-python/)
   (no cuesta dinero usarlo, si no quieres ... hay distribuciones de
   Python creadas por empresas que te cobran principalmente por
   asesorarte en su uso), y además es
   [abierto](https://es.wikipedia.org/wiki/Software_de_c%C3%B3digo_abierto). Esto
   último es importante para muchas
   [empresas](https://www.muycanal.com/2020/02/19/las-empresas-prefieren-el-codigo-abierto-para-su-software-empresarial)
   y organizaciones
   ([CERN](https://home.cern/science/computing/open-source-open-science),
   [NASA](https://code.nasa.gov/)).
3. Uno de los pocos lenguajes de programación que se podría calificar
   como *democrático*, diseñado por la comunidad de Python para la
   comunidad de Python que es muy grande y lo [evoluciona
   constantemente](https://www.python.org/dev/peps/).
4. Un [lenguaje de propósito
   general](http://enciclopedia.us.es/index.php/Lenguaje_de_prop%C3%B3sito_general)
   (no está especializado en resolver ningún tipo de problema en
   concreto) y dispone de una [biblioteca de
   código](https://pypi.org/) enorme (con más de 250.000 paquetes), lo
   que hace que
   [prototipar](https://es.wikipedia.org/wiki/Modelo_de_prototipos)
   con Python sea fácil y rápido.
4. [Uno de los más demandados](http://pypl.github.io/PYPL.html),
   especialmente en el ámbito docente y científico (especialmente, en
   el campo de la [Inteligencia
   Artificial](https://es.wikipedia.org/wiki/Inteligencia_artificial)).

## ¿Sobre qué vamos a programar?

Vamos programar sobre un
[PC](https://es.wikipedia.org/wiki/Computadora_personal#:~:text=Una%20computadora%20personal%2C%20computador%20personal,las%20computadoras%20IBM%20PC%20compatibles.)
con [Linux](https://es.wikipedia.org/wiki/GNU/Linux), en concreto una
versión de Linux llamada [Xubuntu](https://xubuntu.org/), aunque
Python puede usarse [casi](https://www.python.org/download/other/) en
cualquier plataforma actual.

## ¿Qué vamos a programar?

Básicamente, vamos a diseñar e implementar 3 programas:

1. Un comprobador de [números
   primos](https://es.wikipedia.org/wiki/N%C3%BAmero_primo).
2. Un juego de adivinanza de [números
   naturales](https://es.wikipedia.org/wiki/N%C3%BAmero_natural).
2. Una versión personalizada del juego
   [Pong](https://en.wikipedia.org/wiki/Pong), que [no es la primera
   vez que se porta a
   Python](https://sites.google.com/site/thepythonpongtutorial/home).

## Tecnicamente (desde el punto de vista de la programación) aprenderemos ...

1. A distinguir y reconocer las partes básicas de una
   [computadora](https://es.wikipedia.org/wiki/Computadora).
2. A comprender qué es un [lenguaje de
   programación](https://es.wikipedia.org/wiki/Lenguaje_de_programaci%C3%B3n).
3. A comprender qué es un
   [algoritmo](https://es.wikipedia.org/wiki/Algoritmo) y a
   implementarlos.
4. A distinguir entre lenguajes
   [compilados](https://es.wikipedia.org/wiki/Lenguaje_de_programaci%C3%B3n_compilado)
   e
   [interpretados](https://es.wikipedia.org/wiki/Int%C3%A9rprete_(inform%C3%A1tica)).
5. A interpretar qué es la [potencia de
   cómputo](https://en.wikipedia.org/wiki/Computer_performance).
6. A usar el [intérprete de
   Python](https://docs.python.org/3/tutorial/interpreter.html).
7. La [sintaxis básica de
   Python](https://www.w3schools.com/python/python_syntax.asp).
8. Algo sobre la [PLL (Python Standard
   Library)](https://docs.python.org/3/library/) y cómo usarla.
9. Algunos conceptos sobre [programación orientada a
   objetos](https://es.wikipedia.org/wiki/Programaci%C3%B3n_orientada_a_objetos).
10. Algunos conceptos básicos sobre programación de
    [vídeojuegos](https://es.wikipedia.org/wiki/Videojuego).

## Pero antes, una comparativa interesante

* [El coche más potente del mundo](https://www.autocasion.com/actualidad/pruebas/nuevo-lotus-evija-coche-mas-potente-mundo-fotos-info#:~:text=Con%202.000%20CV%20de%20potencia,presentado%20por%20el%20fabricante%20sueco.).
* [El ordenador más potente del mundo](https://computerhoy.com/reportajes/tecnologia/ibm-summit-superordenador-mas-potente-del-mundo-627963).
* [Evolucion de las computadoras y coches](https://www.muycomputer.com/2017/02/05/coches-evolucionado-ritmo-pc/).

## Otros links interesantes (... pero esto, para cuando estés aburrido)

* [La primera computadora (infobae)](https://www.infobae.com/america/tecno/2019/10/14/cual-fue-la-primera-computadora-de-la-historia/).
* [La primera generación de computadoras (wikipedia)](https://es.wikipedia.org/wiki/Primera_generaci%C3%B3n_de_computadoras).
* [El triunfo de los nerds (Wikipedia)](https://es.wikipedia.org/wiki/El_triunfo_de_los_nerds).
* [El triunfo de los nerds Cap 1/3](https://www.youtube.com/watch?v=6KgYRX-cNxA).
* [El triunfo de los nerds Cap 2/3](https://www.youtube.com/watch?v=87EFyQN_Q-E).
* [El triunfo de los nerds Cap 3/3](https://www.youtube.com/watch?v=Ofli7d0mtOU).
* [Nerds 2.0.1 - A Brief History of the Internet - Cap 1/2: Networking The Nerds](https://www.youtube.com/watch?v=L4D2nxQBmOM). [Aquí](http://forohistorico.coit.es/index.php/multimedia/videoteca/item/the-triumph-of-the-nerds-the-rise-of-accidental-empires) está con más calidad.
* [Nerds 2.0.1 - A Brief History of the Internet - Cap 2/2: Serving the Suits](https://www.youtube.com/watch?v=d0ya8DggDYs).
* [¿Cuál fue el primer videojuego, quién lo creó y por qué?](https://plarium.com/es/blog/el-primer-videojuego/).
* [Video Tennis For Two (1958)](https://www.youtube.com/watch?v=6PG2mdU_i8k), diseñado por [William Higinbotham](https://en.wikipedia.org/wiki/William_Higinbotham).
* [Pong en una Magnavox Odyssey (1972)](https://www.youtube.com/watch?v=jLGBtkKPj2U), la primera video-consola comercial.
* [Pong en una máquina arcade de Atari (1972)](https://www.youtube.com/watch?v=YmzH4E3x1_g).
* [Pong en una consola Super Pong de Atari (1976)](https://www.youtube.com/watch?v=9pSMU20bt2M).

## <a id="ejer_0"></a>Ejercicio 0: Di: "¡Hola Mundo!" en Python

Pues eso. Todos los programadores comienzan aprendiendo un lenguaje
nuevo implementando el "Hello World!". Para ello:

1. Abre un terminal y ejecuta:
   ```bash
   pyenv activate curso_python
   ```
   Esto sirve para usar una versión específica de Python (la 3.8.5,
   véase la sección de aprovisionamiento más abajo) y con sus propias
   bibliotecas, para no interferir así con el *ecosistema* de Python
   usado por el [sistema
   operativo](https://es.wikipedia.org/wiki/Sistema_operativo).

2. Ejecuta el [IDE (Integrated Development
   Environment)](https://en.wikipedia.org/wiki/Integrated_development_environment)
   que usaremos para programar y que se llama
   [Thonny](https://thonny.org/):
   
   ```bash
   thonny &
   ```
   
   El símbolo `&` indica que el comando `thonny` se va a ajecutar en
   [background](https://en.wikipedia.org/wiki/Background_process)
   dentro del [shell](https://en.wikipedia.org/wiki/Unix_shell).

3. Escribir el siguiente código:

   ```python
   print("¡Hola Mundo!")
   ```
   
   y almacenarlo en un archivo llamado `hello_world.py` (la extensión
   `py` indica que se trata de un módulo de Python (así es como se
   llaman los archivos en Python), aunque esto es irrelevante para el
   sistema operativo Linux).
   
4. Ejecutarlo. Esto lo podemos hacer de dos maneras diferentes:
   1. Escribiendo en el terminal (también llamado shell):
   
	  ```bash
	  python hello_world.py
	  ```
	  
   2. Pulsando el botón de *Run* (es verde y tiene un triángulo blanco
      dentro) de Thonny.

<!-- Primera parada técnica -->

## <a id="ejer_1"></a>Ejercicio 1: Compilación vs Interpretación
En el [Ejercicio 0](#ejer_0) hemos interpretado el módulo
`hello_world.py`. Para ello, hemos ejecutado el intérprete ( `python`)
y a éste le hemos pasado como argumento el nombre del módulo
(`hello_world.py`). Ahora vamos a ejecutar un programa escrito en el
lenguaje C, llamado
[`cpu_test.c`](https://raw.githubusercontent.com/vicente-gonzalez-ruiz/YAPT/master/workshops/programacion_python_ESO/cpu_test.c). Como
C es un lenguaje compilado, tendremos que compilar el programa antes
de ejecutarlo.

1. En un terminal ejecutar:
   ```bash
   gcc cpu_test.c -o cpu_test -lm
   ```
   
2. El comando anterior genera un archivo ejecutable llamado
   `cpu_test`. Para ejecutarlo, escribir:
   
   ```bash
   ./cpu_test 100000000
   ```
   
   donde el parámetro `100000000` es el número de operaciones en punto
   flotante (raíces cuadradas en nuestro ejemplo) que se van a
   realizar. Tras efectuarlas, el programa mostrará cuántas (en
   millones) se han ejecutado por segundo. Los archivos resultantes de
   una compilación ([código
   máquina](https://en.wikipedia.org/wiki/Machine_code) compilado) son
   dependientes de *la plataforma*
   ([CPU](https://en.wikipedia.org/wiki/Central_processing_unit) +
   [SO](https://es.wikipedia.org/wiki/Sistema_operativo)), pero corren
   más rápido que los interpretados porque la CPU ejecuta directamente
   el código máquina de nuestro programa. Cuando las aplicaciones se
   interpretan, la CPU en realidad ejecuta el intérprete, que es quien
   ejecuta las instrucciones del [código
   fuente](https://en.wikipedia.org/wiki/Source_code) del
   programa. Por contrapartida, los programas interpretados no tienen
   que compilarse y por tanto, no dependen de la plataforma (siempre y
   cuando [exista un intérprete para dicha
   plataforma](https://www.python.org/downloads/)).

## <a id="ejer_2"></a>Ejercicio 2: Averigua si un número natural N es primo

Los números primos son la base de la [criptografía
asimétrica](https://es.wikipedia.org/wiki/Criptograf%C3%ADa_asim%C3%A9trica)
(también llamados algoritmos criptográficos de clave pública) y son
muy importantes para [*esconder* información
digital](https://www.lasexta.com/tecnologia-tecnoxplora/ciencia/divulgacion/principios-basicos-encriptacion-entender-como-snowden-jugo-casa-blanca_2013082657fc98e90cf2fd8cc6b0d634.html),
desarrollar
[firmas](https://academy.binance.com/es/security/what-is-public-key-cryptography)
y
[monedas](https://es.cointelegraph.com/explained/what-is-asymmetric-cryptography)
digitales, desarrollar algoritmos de
[hashing](https://es.wikipedia.org/wiki/Tabla_hash), etc.

Un [número natural](https://es.wikipedia.org/wiki/N%C3%BAmero_natural)
N es primo si ninguna de las divisiones de N entre los enteros primos
menores sqrt(N) (la raíz cuadrada de N) divide a N de forma
exacta. Este algoritmo puede verse
[aquí](http://www.ceiploreto.es/sugerencias/ceibal/Primo_o_compuesto/cmo_saber_si_un_nmero_es_primo.html).

Por tanto, nuestro problema de averiguar si un número natural N es
primo o no (entonces, se dice que es compuesto) se puede dividir en 2
subproblemas:
1. Determinar la lista de los números primos menores o iguales que
   sqrt(N).
2. Dividir N entre todos los números P de dicha lista, y para cada uno
   de ellos comprobar:
   1. Si N es divisible entre P, entonces N es compuesto y debemos
      terminar el algoritmo.
3. Si hemos llegado hasta aquí en el algoritmo, entonces N es primo.

El paso número 1 es famoso desde hace más de 2000 años y se conoce
como [La Criba de
Erastótenes](https://es.wikipedia.org/wiki/Criba_de_Erat%C3%B3stenes). Recreando
lo que podemos encontrar en la Wikipedia, debemos:
1. Crear una lista con todos los números naturales superiores a 2
   (recuerda que el 1 divide a todos los números de forma exacta) y
   menores o iguales que sqrt(N). Esto se puede hacer en Python
   escribiendo:
   
   ```python
   primes = []
   for i in range(2, int(math.sqrt(N))+1):
	   primes.append(i)
   ```
   
2. Para cada número en la lista, comenzando por el 2, eliminaremos
   todos sus múltiplos en dicha lista:
   
   ```python
   for i in range(2, int(math.sqrt(N))+1):
	   if i in primes:
		   for j in range(i*2, int(math.sqrt(N))+1, i):
			   if j in primes:
				   primes.remove(j)
   ```

   En este punto, `primes` contiene la lista de todos los números
   naturales entre 2 y sqrt(N), y que son números primos.
   
3. Finalmente, sólo nos queda comprobar si alguno de los números de la
lista con la criba divide de forma exacta a N:

	```python
	N_is_prime = True          # Variable que indicará si N es primo
	for i in primes:           # Para todos los elementos de la lista primes
		if N % i == 0:         # Si i divide a N
			N_is_prime = False # Entonces N no es primo
			break              # Salir del bucle
    ```

Una posible solución a este ejercicio puede se encuentra
[aquí](https://raw.githubusercontent.com/vicente-gonzalez-ruiz/YAPT/master/workshops/programacion_python_ESO/check_prime.py). Si
tienes curiosidad, la Wikipedia nos habla sobre [los números primos más
grandes
conocidos](https://es.wikipedia.org/wiki/Mayor_n%C3%BAmero_primo_conocido).

## <a id="ejer_3"></a>Ejercicio 3: Bueno, juguemos un poco ahora ... y ¡averigua el número!
Dejemos un poco de lado a las matemáticas y vamos programar juegos
sencillos. El primero de ellos consiste en adivinar qué número, dentro
de un rango, ha elegido de forma aleatoria la
computadora. Básicamente, nuestro juego consistiría en:

1. Generar un número aleatorio (dentro de un rango que el jugador debe
conocer). Llamemos `random_number` a dicho número. Una forma de hacer
esto es usar el método
[`random.randrange()`](https://docs.python.org/3/library/random.html#random.randrange)
de la PSL.
2. Solicitar al jugador un número usando
   [`input()`](https://www.w3schools.com/python/ref_func_input.asp). Llamémoslo
   `guessed_number`. En la solución del [Ejercicio 2](#ejer_2) hay un
   ejemplo de cómo solicitar una entrada al programa desde el teclado.
3. Mientras el jugador no adivine el número (mientras `guessed_number != random_number`):
   1. Indicar al jugador si `random_number` es mayor o menor que
      `guessed_number`.
   2. Solicitar al jugador un nuevo `guessed_number`.

Tras implementar nuestro juego y ejecutarlo unas cuantas veces, aprenderemos que podemos siempre adivinar el número a lo sumo en `log_2(N)` (`= log(N)/log(2)`) intentos, que es la complejidad algorítmica de la [búsqueda binaria](https://en.wikipedia.org/wiki/Binary_search_algorithm).

Una posible solución a este ejercicio puede
encuentrarse
[aquí](https://raw.githubusercontent.com/vicente-gonzalez-ruiz/YAPT/master/workshops/programacion_python_ESO/guess_the_number.py). Otra implementación podría ser [esta](https://github.com/grantjenks/free-python-games/blob/master/freegames/guess.py), que es parte del paquete [freegames](https://pypi.python.org/pypi/freegames).

## <a id="ejer_4"></a>Ejercicio 4: Crear una ventana vacía (empty screen) usando Pygame
El segundo (y último juego) que vamos a implementar en este curso de
programación con Python es una versión del videojuego Pong. Para
desarrollarlo más fácilmente, nos vamos a apoyar en el uso del paquete
[Pygame](https://www.pygame.org/news), que ofrece una
[API](https://en.wikipedia.org/wiki/API) para programar videojuegos en
Python. Lo primero que vamos a hacer es aprender a abrir (y cerrar) un
[display](https://www.pygame.org/docs/ref/display.html) (una ventana
(window) o una pantalla (screen), dependiendo del sistema gráfico
porporcionado por la computadora y el
[SO](https://es.wikipedia.org/wiki/Sistema_operativo)) en el que nos
encontremos programando (por ejemplo, en Xubuntu, el sistema gráfico
es el [X Window
System](https://es.wikipedia.org/wiki/Sistema_de_ventanas_X)) y el
gestor de ventanas [`XFCE`](https://www.xfce.org/).

Bien, para implementar este ejercicio tendremos que:

1. Importar Pygame (escribir la instrucción de Python `import
   pygame`).
2. Inicializar Pygame (usar el método
   [`pygame.init()`](https://www.pygame.org/docs/ref/pygame.html#pygame.init)).
3. Crear una ventana (usar
   [`pygame.display.set_mode()`](https://www.pygame.org/docs/ref/display.html#pygame.display.set_mode)).
4. Opcionalmente, darle un título a la ventana (usar
   [`pygame.display.set_caption()`](https://www.pygame.org/docs/ref/display.html#pygame.display.set_caption)).
5. Esperar a que el usuario cierre la ventana (cosa que ocurre, cuando
   [`pygame.event.wait().type`](https://www.pygame.org/docs/ref/event.html#pygame.event.wait)
   retorna un evento del tipo
   [`pygame.QUIT`](https://www.pygame.org/docs/ref/event.html)).
6. Cuando el usuario haya cerrado la ventana, cerrar también Pygame
   (usar
   [`pygame.quit()`](https://www.pygame.org/docs/ref/pygame.html#pygame.quit)).

Una posible solución está disponible [aquí](https://raw.githubusercontent.com/vicente-gonzalez-ruiz/YAPT/master/workshops/programacion_python_ESO/empty_display_v0.py). Además, gran cantidad de información sobre cómo programar juegos usando Pygame
puede encontrarse en [Programar Juegos Arcade con Python y
Pygame](http://programarcadegames.com/).

## <a id="ejer_5"></a>Ejercicio 5: Pintar un par de puntos
Además de aprender cómo dibujar puntos, el objetivo de este ejercicio
es averiguar cómo se distribuyen las coordenadas en un display de
Pygame. Implementar:

1. Importar Pygame (ídem [Ejercicio 4](#ejer_4)).
2. Inicializar Pygame (ídem [Ejercicio 4](#ejer_4)).
3. Crear una pantalla (ídem [Ejercicio 4](#ejer_4)).
4. Darle un título a la pantalla (ídem [Ejercicio 4](#ejer_4)).
5. Pintar un punto blanco en la coordenadas (x=1, y=1) (usar [`pygame.screen.set_at()`](https://www.pygame.org/docs/ref/surface.html#pygame.Surface.set_at)).
6. Pintar un punto verde en (x=10, y=100).
7. Actualizar la ventana usando [`pygame.display.update()`](https://www.pygame.org/docs/ref/display.html#pygame.display.update).
8. Esperar a que el usuario cierre la pantalla (ídem [Ejercicio 4](#ejer_4)).
9. Cerrar Pygame (ídem [Ejercicio 4](#ejer_4)).

Una posible solución es [esta](https://raw.githubusercontent.com/vicente-gonzalez-ruiz/YAPT/master/workshops/programacion_python_ESO/plot_pixels_v0.py).

## Pero ... estamos escribiendo dos veces lo mismo :-/
Si comparamos el código (fuente) desarrollado para los Ejercicios
[4](#ejer_4) y [5](#ejer_5), apreciaremos que son casi idénticos. Esto
puede ser interesante cuando queremos que ambos módulos sean
completamente independientes, de manera que si modificamos uno, el
comportamiento del otro no se vea afectado. Sin embargo, en general
tener código duplicado no es una buena idea porque dificulta su
mantenimiento. Por ejemplo, si nos damos cuenta de que en la solución
del [Ejercicio 4](#ejer_4) hemos cometido un error, casi seguro que
dicho error está también en la solución del [Ejercicio 5](#ejer_5),
porque reutiliza mucho de su código. Lo ideal sería que las
implementaciones de ambos ejercicios compartieran el código que tienen
en común.

La solución más frecuente y quizás elegante para resolver la
duplicación de código pasa por utilizar el [Paradigma de Programación
Orientada a
Objetos](https://es.wikipedia.org/wiki/Programaci%C3%B3n_orientada_a_objetos),
o en inglés,
[OOP](https://en.wikipedia.org/wiki/Object-oriented_programming).

## Pensando en objetos
La OOP ayuda a organizar el código fuente de tus programas y a hacer
que éstos se puedan mantener (por ejemplo, encontrar
[bugs](https://es.wikipedia.org/wiki/Error_de_software) (en español:
bichos, aunque todo el mundo usa la palabra inglesa), a lo que también
se llama
[depurar](https://es.wikipedia.org/wiki/Depuraci%C3%B3n_de_programas)
( [debugging](https://en.wikipedia.org/wiki/Debugging) en inglés) más
fácilmente. La idea es organizar el código en clases (así se llaman
estructuras de datos (llamadas a su vez *atributos* en el contexto de
la OOP) y funciones (llamadas normalmente *métodos* en el contexto de
la OOP) asociadas)), y utilizar la
[herencia](https://es.wikipedia.org/wiki/Herencia_(inform%C3%A1tica))
para evitar reimplementar lo ya implementado (las clases heredan el
comportamiento de las clases *ancestro*, también llamadas clases
*base*, clases *padre* (cuando la herencia es directa), ...). A las
instancias de las clases se les llama *objetos*, y en Python [casi
todo lo que manejamos son
objetos](https://docs.python.org/3/reference/datamodel.html). Por
ejemplo, para implementar la Criba de Erastótenes del [Ejercicio
2](#ejer_2) hemos instanciado un objeto de [clase
lista](https://www.w3schools.com/python/python_lists.asp) (`primes`)
de la PSL.

Veamos un ejemplo de diseño de clases. Supongamos que vamos a
implementar un programa que trabaja con gatos y perros, y queremos que
cuando un perro o un gato sean instanciados (cuando creemos un objeto
usando la clase *Dog* o la clase *Cat* (las clases en Python suelen
comenzar con una letra en mayúscula)), aparezca un mensaje que indique
tal acción, y cuando sean borrados de la memoria de la computadora
aparezca otro mensaje indicando también dicha acción. Usando la OOP,
podemos definir 3 clases:
[`Animal`](https://raw.githubusercontent.com/vicente-gonzalez-ruiz/YAPT/master/workshops/programacion_python_ESO/animal.py),
[`Cat`](https://raw.githubusercontent.com/vicente-gonzalez-ruiz/YAPT/master/workshops/programacion_python_ESO/cat.py)
y
[`Dog`](https://raw.githubusercontent.com/vicente-gonzalez-ruiz/YAPT/master/workshops/programacion_python_ESO/dog.py),
usando la siguiente (relación de) herencia:

```
    +--------+
    | Animal |
    +---+----+
        |
   +----+----+
   |         |
   v         v
+--+--+   +--+--+
| Cat |   | Dog |
+-----+   +-----+
```

indicando que un objeto de la clase `Cat`y otro de la clase `Dog` son
ambos animales, y por tanto, comparten el comportamiento definido en la
clase `Animal`. Podemos comprobar esto ejecutando en el terminal:

```bash
python animal.py

```
Luego ejecutando:

```bash
python dog.py

```

Y finalmente, ejecutando:

```bash
python cat.py

```

Si nos fijamos bien en los mensajes que aparecen en el terminal,
cuando desde los módulos `cat.py` y `dog.py` se hace un `import
animal`, el código que hay en el bloque del `__main__` no se
ejecuta. Eso es porque cuando hacemos un `import`, la variable
`__name__` tiene el nombre del módulo.

## <a id="ejer_6"></a>Ejercicio 6: Reimplementamos los Ejercicios [4](#ejer_4) y [5](#ejer_5) usando la OOP
Vamos a definir 2 clases en 2 módulos (archivos) diferentes:
1. Una clase padre, llamada `EmptyDisplay`, en la que vamos a definir
   3 métodos:

   1. El constructor `__init__(self, width, caption)`, en el que
      crearemos un display vacío. Entre paréntesis hemos representado
      sus parámetros:

	  1. `self`, que [representa los atributos que de forma dinámica
         son
         creados](https://medium.com/quick-code/understanding-self-in-python-a3704319e5f0).
		 
	  2. `width`, que indica el ancho de la ventana, en pixels.
	  
	  3. `height`, que indica el alto de la ventana, en pixels.
	  
	  4. `caption`, con el nombre de la ventana.
	  
	  Todos los constructures de clase en Python tienen por nombre
	  `__init__`.
  
   2. El destructor `__del__(self)`, en el que cerraremos el
      display. Nótese que el primer parámetro de todos los métodos de
      una clase debe ser `self` (que no es más que una convención, en
      realidad podría usarse cuanquier otro nombre para este
      parámetro). `__del__` es una palabra reservada para el
      destructor.

   3. Un método llamado `run(self)`, que implementará la lógica
      necesaria para esperar a que se cierre la ventana. `run` no es
      una palbra reservada (el método podría tener cualquier otro
      nombre).

   <!--4. Un método denominado `get_event(self)`, que retorna un evento
      (por ejemplo, el cierre de la ventana). El método `run(self)`
      llamará a `get_event(self)`.-->
   
2. Una clase hija que hereda de la clase `EmptyDisplay`, llamada
   `PlotPlixels`, que *sobreescribirá* el método `EmptyDisplay.run()`
   con la loǵica necesaria para pintar los dos pixels pixels y luego,
   esperar a que se cierre la ventana.

Una posible solución está disponible en
[`empty_display.py`](https://raw.githubusercontent.com/vicente-gonzalez-ruiz/YAPT/master/workshops/programacion_python_ESO/empty_display.py)
y
[`plot_pixels.py`](https://raw.githubusercontent.com/vicente-gonzalez-ruiz/YAPT/master/workshops/programacion_python_ESO/plot_pixels.py). Nótese
que además hará falta el módulo `colors.py` que debe estar dentro de
una carpeta llamada `lib` (crear la carpeta escribiendo en el terminal
`mkdir lib` y mover `colors.py` dentro con `mv colors.py lib`). En
este módulo han sido definidos algunos colores básicos (véase la
aplicación [`Gcolor2`](http://gcolor2.sourceforge.net/) normalmente
instalada en XFCE). La razón por la que `colors.py` se colocan dentro
de la carpeta `lib` es porque si por casualidad hubiera algún paquete
en la [PSL](https://docs.python.org/3/library/) o en
[PyPI](https://pypi.org/) llamado también `colors`, evitaríamos que
nuestro `colors` enmascarara al paquete "estándar".

Nótese que tenemos:
```
+--------------+
| EmptyDisplay |
+------+-------+
       |
       |
       v
 +-----+------+
 | PlotPixels |
 +------------+
```

## <a id="ejer_7"></a>Ejercicio 7: Pintar un rectángulo
La pelota de nuestro Pong va a ser un cuadrado. Aprendamos a dibujar
rectángulos:

1. Crear una clase llamada `DrawRectangle` que herede de la clase
   `EmptyDisplay`.
   
2. Sobreescribir el método `EmptyDisplay.run()` para que se pinte un
   rectángulo y termine (nuestro programa), cuando dicho evento se
   produzca. Para dibujar un rectángulo podemos usar el método
   [`pygame.draw.rec()`](https://www.pygame.org/docs/ref/draw.html#pygame.draw.rect). Recuerda
   que, tras pintar todas las *estructuras* que deseemos, tenemos que
   invocar el método
   [`pygame.display.update()`](https://www.pygame.org/docs/ref/display.html#pygame.display.update)
   para que estas sean mostradas en la pantalla.
   
Una posible solución puede encontrarse en
   [`draw_rectangle.py`](https://github.com/vicente-gonzalez-ruiz/YAPT/blob/master/workshops/programacion_python_ESO/draw_rectangle.py).

## <a id="ejer_8"></a>Ejercicio 8: Rellena un area de colores
Vamos a rellenar un cuadrado en el centro de la ventana con píxeles de cientos de colores. Algo como:

```
+-----------------------------+
|                             |
|                             |
|                             |
|         +--------+          |
|         |********|          |
|         |********|          |
|         |********|          |
|         +--------+          |
|                             |
|                             |
|                             |
+-----------------------------+
```
Decide tú el tamaño del cuadrado, pero, que esté centrado horizontal y verticalmente. Como suele ya siendo habitual:

1. Crear una clase llamada `DrawColorSquare` que herede de la clase
   `EmptyDisplay`.
   
2. Sobreescribir el método `EmptyDisplay.run()` para que pinte el
   cuadrado.

## <a id="ejer_9"></a>Ejercicio 9: Rebota el rectángulo en los lados de la ventana
En nuestro Pong la pelota rebotará en los límites del display. Hagamos
que el rectángulo se mueva en diagonal, a velocidad constante a razón
de un pixel en horizontal y otro en vertical por cada frame
presentado, rebotando en las paredes de la ventana. En concreto:

1. Crear una clase llamada `BouncingBall` que herede de la clase
   `EmptyDisplay`.

2. Sobreescribir el método `EmptyDisplay.run()` para que rebote la
   pelota (que será un cuadrado blanco). En este método tendremos que
   controlar la posición de la pelota, y en lugar de usar
   `pygame.event.wait()` para detener la ejecución de la aplicación
   hasta que no se produzca un nuevo evento, usaremos el método
   [`pygame.event.get()`](https://www.pygame.org/docs/ref/event.html#pygame.event.get),
   que lo que hace básicamente es sacar de la cola de eventos el
   siguiente disponible y retornar inmediatamente, tanto si la cola
   tiene elementos como si está vacía. A este último tipo de
   instrucciones se les llama *no bloqueantes*, porque retornan de su
   llamada tan pronto como es posible. Nótese que, por el contrario,
   `pygame.event.wait()` es un método bloqueante.
   
   `pygame.event.get()` debe utlizarse así (si lo que deseamos es
   cerrar el display de Pygame cuando "matamos" la ventana):

   ```python
   for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
   ```
   
   y nos permitirá pintar los contenidos (lo que se conoce normalmente
   en el mundo de los videojuegos como *frame*) en nuestra ventana tan
   rápido como deseemos (o sea posible con los recursos de los que
   disponemos).
   
3. Recuerda que para que los gráficos aparezcan en la ventana, esta
   tiene que actualizarse con
   [`pygame.display.update()`](https://www.pygame.org/docs/ref/display.html#pygame.display.update).
   
Una posible solución a este ejercicio está disponible en
[`bouncing_ball.py`](https://raw.githubusercontent.com/vicente-gonzalez-ruiz/YAPT/master/workshops/programacion_python_ESO/bouncing_ball.py).

## <a id="ejer_10"></a>Ejercicio 10: Usando sprites. Versión 0 de Pong
Básicamente, un
[sprite](https://www.pygame.org/docs/tut/SpriteIntro.html) es un
objeto gráfico 2D que cuando se mueve permite detectar colisiones con
otros objetos. Pygame proporciona la clase
[`pygame.sprite.Sprite`](https://www.pygame.org/docs/ref/sprite.html)
con dicha funcionalidad. Lo que vamos a hacer ahora es reescribir el
[Ejercicio 9](#ejer_9) usando sprites.

Básicamente nuestro diseño será:

```
    +---------------------------------------+
    |               upper wall              |
+---+---------------------------------------+---+
|   |                                       |   |
| l |                                       | r |
| e |                                       | i |
| f |                                       | g |
| t |                                       | h |
|   |                                       | t |
|   |                                       |   |
| w |      +---+                            | w |
| a |      |   | Ball                       | a |
| l |      +---+                            | l |
| l |                                       | l |
|   |                                       |   |
+---+---------------------------------------+---+
    |               lower wall              |
    +---------------------------------------+
```

donde todos los sprites son cuadrados (la pelota) o rectangulares (las
paredes).

### Creando un sprite rectangular, homogéneo (sólido) y estático
Para crear un sprite de este tipo debemos heredar la clase
`pygame.sprite.Sprite` y en nuestra clase hija:
1. LLamar al constructor de la clase `pygame.sprite.Sprite`
   escribiendo
   
   ```python
   super().__init__()
   ```

2. Crear la superficie que ocupa el sprite con

   ```python
   self.image = pygame.Surface([width, height])
   ```
   
   donde `width` es el número de pixels del sprite en horizontal y
   `height` el número de pixels del sprite en vertical. La superficie
   debe llamarse `self.image`, ya que este objeto se llama así en la
   clase padre.

3. Pintar el sprite con el color
   deseado. [Usar](https://www.pygame.org/docs/ref/surface.html#pygame.Surface.fill)

   ```python
   self.image.fill(color)
   ```
   
   donde color es el color del sprite.

4. Indicar el color transparente del sprite [usando](https://www.pygame.org/docs/ref/surface.html#pygame.Surface.set_colorkey)

   ```python
   self.image.set_colorkey(color)
   ```
   
   donde `color` es el color del sprite que deseamos que sea
   transparente (que no se pinte). La llamada a este método es
   obligatorio o de lo contrario el sprite se pinta pero no se
   detectan las colisiones con él. `color` puede ser cualquier color,
   excepto el color del sprite (o de lo contrario, no se pintará). En
   nuestro caso, hemos elejido el color negro.
   
5. Indicar la posición del sprite, asignando valores a `self.rect.x` y
   `self.rect.y`. El objeto [`surface`](https://www.pygame.org/docs/ref/surface.html#pygame.Surface.get_rect)
   
   ```python
   self.rect = self.image.get_rect()
   ```
   
   debe obtenerse de esta forma, y lo que hace es devolver el
   *bounding box* (esquina superior izquierda y dimensiones) del
   sprite.

### Moviento un sprite
Para desplazar un sprite simplemente tenemos que sobreescribir el
método `update()` y especificar los nuevos valores de
`self.rect.x` y de `self.rect.y`. Pero ojo, esto sólo tendrá efecto
tras llamar a los métodos:
1. [`pygame.sprite.Sprite.update()`](https://www.pygame.org/docs/ref/sprite.html#pygame.sprite.Sprite.update) usando

   ```python
   self.all_sprites_list.update()
   ```
   
   [donde](https://www.pygame.org/docs/ref/sprite.html#pygame.sprite.Group)
   
   ```python
   self.all_sprites_list = pygame.sprite.Group()
   ```
   
2. [`pygame.sprite.Group.draw()`](https://www.pygame.org/docs/ref/sprite.html#pygame.sprite.Group.draw) mediante

   ```python
   self.all_sprites_list.draw(self.display)
   ```

3. [`pygame.display.update()`](https://www.pygame.org/docs/ref/display.html#pygame.display.update)

   ```python
   pygame.display.update()
   ```
   
Los dos primeros métodos deben invocarse cuando queremos que los
sprites se muevan *en memoria*, y esto debería ocurrir si el
movimiento es tan rápido que no podría ser apreciado por un ser humano
(normalmente, por encima de 60 Hz no aumenta la sensación de
movimiento). El último método se debe llamar para que todos los
cambios realizados en el frame sean mostrados.

Sobre ¿por qué puede ser interesante trabajar con una frecuencia de
renderizado mayor que una frecuencia de refresco?, hay algún [vídeo
interesante](https://www.youtube.com/watch?v=lS_G2XSYVl4) que lo
explica, aunque básicamente se hace para aumentar la precisión de la
detección de colisiones entre sprites que se mueven de forma discreta,
a grandes saltos (puede ocurrir que los sprites *se crucen*, como si
fueran fantasmas inmateriales, y no se detectarían las colisiones).

En nuestra versión de Pong el paso de movimiento máximo de la pelota
jamás superará el tamaño de la misma (16x16 pixels), y por tanto, la
frecuencia de renderizado del juego (en memoria) y la frecuencia de
pintado de los frames pueden ser iguales.

### Detectando una colisión entre 2 sprites
Una vez que los sprites han sido instanciados, deben colocarse en una
lista instanciada por el método
[`pygame.sprite.Group()`](https://www.pygame.org/docs/ref/sprite.html#pygame.sprite.Group). Ejemplo:

```python
self.all_sprites_list = pygame.sprite.Group()
self.all_sprites_list.add(self.ball)
```

donde `self.ball` sería el sprite (una instancia de la clase Ball que
hereda de la clase Sprite) de nuestra pelota.

Podemos detectar la colisión (a nivel de pixel dibujado) entre dos sprites (pongamos, `self.ball` y `self.upper_wall`) usando:

```python
if pygame.sprite.collide_mask(self.ball, self.upper_wall):
    self.ball_hits_upper_wall()
```

donde `self.ball_hits_upper_wall()` sería el método que se encargaría
de gestionar la colisión entre la pelota y el muro superior. Por
ejemplo, podría emitir algún sonido y decidir la nueva trayectoria de
la pelota.

### Pong_v0

Pong_v0 implementa la pelota rebotanto en diagonal contra las 4
paredes. Los 5 elementos son sprites. Necesitaremos:

1. Declarar una clase `Ball` que herede de
   [`pygame.sprite.Sprite`](https://www.pygame.org/docs/ref/sprite.html#pygame.sprite.Sprite). Esta
   implementa 2 métodos:
   1. `__init__()`: que crea el sprite.
   2. `update()`: que indica cómo mover la pelota.
2. Declarar 4 clases (casi idénticas) con las 4 paredes: `UpperWall`,
   `LowerWall`, `LeftWall` y `RightWall`, todas herederas de
   [`pygame.sprite.Sprite`](https://www.pygame.org/docs/ref/sprite.html#pygame.sprite.Sprite). Ninguna
   de ellas necesita sobreescribir el método `update()`, puesto que no
   se mueven.
3. Declarar la clase `Pong_v0(EmptyDisplay)`. Esta:
   1. En su método `__init__`:
	  1. Inicializar el mezclador de audio con
	  
	     ```python
	     pygame.mixer.pre_init(44100, -16, 1, 512)
	     ```

	  2. LLamar al constructor de `EmptyDisplay` escribiendo
	  
         ```python
		 super().__init__(width, height, caption)
		 ```

	  3. Cargar el sonido de rebote de la pelota con las paredes
         usando
         [`pygame.mixer.Sound()`](https://www.pygame.org/docs/ref/mixer.html#pygame.mixer.Sound):
	  
	     ```python
		 self.rebound_sound = pygame.mixer.Sound(file="4391__noisecollector__pongblipf-5.wav")
		 ```
	  4. [Instanciar la lista de
         sprites](https://www.pygame.org/docs/ref/sprite.html#pygame.sprite.Group)
         con
		 
		 ```python
		 self.all_sprites_list = pygame.sprite.Group()
		 ```
		 
	  5. Instanciar la pelota y las 4 paredes.
	  
	  6. Añadir todos los sprites a la lista de sprites. Todos se van
         a pintar al mismo tiempo. Ejemplo:
		 
		 ```python
		 self.all_sprites_list.add(self.ball)
		 self.all_sprites_list.add(self.lower_wall)
		 self.all_sprites_list.add(self.left_wall)
		 self.all_sprites_list.add(self.right_wall)
		 ```
	  
  2. Procesar los eventos con:
  
     ```python
     def process_events(self):
         for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    self.running = False
     ```
	 
	 Esto permitirá cerrar la ventana al pulsar la tecla <Esc> o al
     hacer click en el botón de cerrar la ventana. Dicho método debe
     llamarse con la frecuencia en que los eventos tienen ser
     procesados. En nuestro caso, como dichos eventos son poco
     frecuentes y no importa cierta latencia entre dar la orden de
     cerrar la ventana y que esto ocurra, el método es llamado dentro
     de un hilo una vez cada segundo y además imprime a través del
     terminal el número de FPS (Frames Per Second) del juego.
	 
  3. Para ejecutar un método de una clase en un hilo, hay que:
  
	 1. Importar:
	 
	    ```python
		import threading
		import time
		```
		
	 2. Declarar el método. Por ejemplo:
	 
   		```python
		def print_FPS(self):
			while self.running:
				print(f"FPS={self.FPS:04.2f}", end='\r' )
				self.process_events()
				time.sleep(1)
	    ```
		
	 3. Crear el hilo con:
	 
	    ```python
		self.print_FPS__thread = threading.Thread(target = self.print_FPS)
		```

	 4. Lanzar el hilo:
	 
	    ``` python
		self.print_FPS__thread.start()
		```
		
	 5. Cuando el módulo haya finalizado, esperar a que el hilo
        finalice también:
		
		```python
		self.print_FPS__thread.join()
		```
  
<!--
## <a id="ejer_9"></a>Ejercicio 9: Crea la clase `EmptyDisplayPoll`
La clase `EmptyDisplay` espera (quedándose bloqueada en la instrucción
`pygame.event.wait()`) a recibir el evento `pygame.QUIT` que indica
que el display ha sido cerrado. Sin embargo, en la inmensa mayoría de
los juegos el método que vamos a usar es el método
`pygame.event.get()`. Para resolver este problema tenemos dos
opciones:

1. La primera es utilizar el método `pygame.event.get()` en todos los
   métodos `run()` de nuestras clases, reescribiendo una y otra vez el
   mismo código.
   
2. La segunda es modificar la clase `EmptyDisplay` añadiendo un nuevo
   método llamado `poll_event()` (que usa `pygame.event.wait()`), que
   para que en una clase hija llamada `EmptyDisplayPoll`
   sobreescribamos el método `poll_event()` (usando la clase
   `pygame.event.get()`). Así tendremos menos código en las clases
   herederas como `BouncingBall`.
-->

## <a id="ejer_9"></a>Ejercicio 9: Calculando los FPS (Frames Per Second)
La clase `BouncingBall` mueve la pelota tan rápido como es posible, y
sería interesante conocer el número de FPS alcanzados, principalmente
porque el ser humano difícilmente puede apreciar más de 100 FPS (de
hecho, en los juegos lo normal es limitar los FPS a 60).

Analicemos un poco el código y veamos cómo podemos informar
periódicamente (porque los FPS pueden variar con el tiempo dependiendo
de la carga de la computadora):

* Ahora mismo tenemos un bucle (el controlado `while self.running`)
que va tan rápido como puede.
* Pygame ofrece el método
  [`self.clock.tick()`](https://www.pygame.org/docs/ref/time.html#pygame.time.Clock.tick)
  que mantiene un cronómetro y que mide el tiempo transcurrido entre 2
  llamadas consecutivas a este método. Si queremos temporizar el
  número de iteraciones del bucle por segundo (que sería el número de
  FPS), este método debe llamarse dentro del bucle.
* Pygame ofrece el método
  [`self.clock.get_fps()`](https://www.pygame.org/docs/ref/time.html#pygame.time.Clock.get_fps)
  que devuelve el número de FPS a partir del cronómetro mantenido por
  `self.clock.tick()`. Por tanto, este método debería llamarse siempre
  que deseamos conocer los FPS.
* El número de mensajes sobre los FPS van a mostrarse con una
  frecuencia de 1 Hz. Por tanto, deberemos en alguna parte definir un
  temporizador en bucle con dicha frecuencia de disparo.
* Ahora mismo sólo disponemos del bucle principal (el controlado
  `while self.running`) que que itera mucho más rápido, y por tanto,
  no nos sirve. Podemos intentar técnicas como imprimir los FPS una
  vez cada X iteraciones, pero esto no deja de ser poco elegante
  sabiendo que en Python disponemos de [hilos
  (`threads`)](https://es.wikipedia.org/wiki/Hilo_(inform%C3%A1tica)).
  
Conociendo todo esto, lo que vamos a hacer para imprimir los FPS a
razón de un mensaje/segundo es crear un hilo que ejecute un bucle que
finalice cuando `self.running == False`, y que llame al método
`self.clock.get_fps()` e imprima el valor retornado.

Véase [`bouncing_ball_FPS.py`](https://raw.githubusercontent.com/vicente-gonzalez-ruiz/YAPT/master/workshops/programacion_python_ESO/bouncing_ball_FPS.py) como posible solución.

## <a id="ejer_10"></a>Ejercicio 10: Añadiendo sonido

Añadir sonido a un juego casi es obligatorio y Pygame nos proporciona
la funcionalidad necesaria.


## Ejercicio: Usar sprites

```
<---------------------- screen_width ----------------------->
+-----------------------------------------------------------+ ^
|    +----------+                                           | |
| <- | computer | ->                                        | |
|    +----------+                                           | |
|                                                           | s
|                                                           | c
|                                                           | r
|                                                           | e
|                                                           | e
|                                                           | n
| - - - - - - - - - - - - - - - - - - - - - - - - - - - - - | _
|                                                           | h
|                                                           | e
|                * <- the ball                              | i
|                                                           | g
|                                                           | h
|                                                           | t
|                 +----------+                              | |
|              <- |  human   | ->                           | |
|                 +----------+                              | |
+-----------------------------------------------------------+ v
```

## Ejercicio: Reutilizar el código de la pantalla vacía para pintar puntos
1. Distribuir el código del Ejercicio 1 en métodos (de una clase
   llamada `Screen`; llamar al fichero que la contiene `screen.py`),
   de forma que la clase creada para el Ejercicio 2 pueda reutilizar:
   (1) la parte de código que crea la ventana, y (2) la parte de
   código que cierra la ventana y Pygame.


```
main():
  computer_points_counter = 0
  human_points_counter = 0
  while (computer_points_counter < 10) and (humman_points_counter < 10):
    if ball_coordinate_y < 0:
	  human_points_counter = human_points_counter + 1
	else if ball_coordinate_y > screen_height:
	  computer_points_counter = computer_points_counter + 1
```

## Open a window

1. [¿Qué es un lenguaje de programación?]().
2. [¿Qué es Python?]().
3. [Sistemas donde corre Python]()-
4. [Un poco de Linux y su consola de comandos]().
5. [Instalación de Python en Linux]().
6. [Hello World en Python](http://localhost:8888/notebooks/YAPT/03-hello_world.ipynb#Hello-world!).
7. [¿Qué es PyGame?](http://localhost:8888/notebooks/YAPT/04-structuring_code.ipynb#Structuring-code).

7. [PacMan](https://github.com/grantjenks/free-python-games/blob/master/freegames/pacman.py) from [Free Python Games](http://www.grantjenks.com/docs/freegames/). See [https://pypi.python.org/pypi/freegames](https://pypi.python.org/pypi/freegames) at [The Python Package Index](https://pypi.python.org/pypi). Extra info at [Using Turtle graphics: a Tkinter based turtle graphics module for Python](http://localhost:8888/notebooks/YAPT/A3-Turtle.ipynb#Using-Turtle-graphics:-a-Tkinter-based-turtle-graphics-module-for-Python).
8. [I/O](http://localhost:8888/notebooks/YAPT/18-IO.ipynb).

## Apéndice A: Comandos básicos del terminal

* `cd` (change directory): permite moverse por el sistema de
  ficheros. Ejemplos:
  ```bash
  cd Downloads  # Entra en el directorio "Downloads"
  cd            # Retorna al "home directory"
  cd ..         # Sube al directorio superior en el sistema de ficheros
  ```

* `ls` (list): muestra el contenido de un directorio. Ejemplos:
  ```bash
  ls            # Listado simple
  ls -l         # Listado largo
  ls -a         # Mostrar ficheros "ocultos"
  ls -R         # Listado recursivo
  ls -lR        # Listado largo y recursivo
  ```
  
* `cat`: muestra el contenido de un archivo. Ejemplos:
  ```bash
  cat mi_fichero
  ```

* `mkdir` (make directory): crea un directorio. Ejemplo:
  ```bash
  mkdir lib
  ```

* `cp` (copy): copia un archivo/directorio. Ejemplos:
  ```bash
  cp hello_world.py copia_de_hello_world.py
  cp -r lib /tmp  # Copia el directorio "lib" al directorio "/tmp"
  ```

* `mv` (move): mueve un archivo/directorio o renobra un
  archivo/directorio. Ejemplos:
  ```bash
  mv hello_world.py hola_mundo.py  # Renombra un archivo
  mv lib biblioteca                # Renombra un directorio
  ```

* `rm` (remove): borra un archivo/directorio PARA SIEMPRE. Ejemplos:
  ```bash
  rm hola_mundo.py  # Elimina el archivo "hola_muldo.py" del sistema de ficheros
  rm -r lib         # Borra el directorio "lib", junto co todos sus contenidos
  ```

* `rmdir` (remove directory): borra un directorio vacío PARA SIEMPRE. Ejemplo:
  ```bash
  rm lib  # Borra el directorio vacío "lib"
  ```

## Apéndice B: Aprovisionamiento
1. Instalar [Xubuntu 20.04 (Focal
   Fossa)](https://xubuntu.org/download/) en un pendrive de al menos 8
   GB. Xubuntu recién instalado ocupa aproximadamente 5 GB.
	* En [Windows](https://ubuntu.com/tutorials/create-a-usb-stick-on-windows#1-overview).
	* En [Ubuntu](https://ubuntu.com/tutorials/create-a-usb-stick-on-ubuntu#1-overview).
	* En [OSX](https://ubuntu.com/tutorials/create-a-usb-stick-on-macos#1-overview).
	* En [Linux](https://askubuntu.com/questions/372607/how-to-create-a-bootable-ubuntu-usb-flash-drive-from-terminal).
    * Indicar que se quiere actualizar Xubuntu mientras se instala (si
      hay conexión a Internet) y que se desea instalar software de
      terceros (propietario).
	* Es preferible seleccionar English como idioma, pero elegir el
      teclado correspondiente (seguramente Español).
    * En *Installation type* hay que seleccionar *Something else*,
	  particionar el pendrive en 3 particiones: (1) /dev/sd<disk>1 de
	  tipo EFI con 512 MB (aproximadamente), (2) /dev/sd<disk>2 de
	  tipo swap con 8 GB (8192 MB, aproximadamente y dependiendo del
	  tamaño del pendrive), y (3) /dev/sd<disk>3 de tipo ext4, con el
	  resto del pendrive, y para montarse en /, que debería ser
	  formateada. Finalmente, no olvidar indicar que el boot loader
	  debe instalarse también en el pendrive /dev/sd<disk>, donde
	  <disk> es una letra, seguramente "b" o "c", dependiendo del
	  número de discos que tengamos instalados en nuestro
	  ordenador. Ojo de no seleccionar, por ejemplo, /dev/sda, porque
	  estaríamos particionando y formateando el primer disco de
	  nuestro ordenador. Nota: es posible que aparezcan huecos
	  pequeños con espacio libre al comienzo de espacio de
	  almacenamiento del pendrive, al final y entre las
	  particiones. Esto no importa y es irremediable.
    * Usuario: "ion".
	* Hostname: "sirius".
    * Contraseña: "curso".

2. [Instalar (usando
   pyenv)](https://github.com/vicente-gonzalez-ruiz/YAPT/blob/master/01-hello_world/02-installation.ipynb)
   la versión 3.8.5 de CPython, y crear un entorno virtual llamado
   "curso_python".

3. Activar el VE `curso_python` escribiendo:
   ```bash
   pyenv activate curso_python
   ```
   en `.bashrc`.

4. Instalar pygame usando pip dentro del VE. Ver
   https://stackoverflow.com/questions/7652385/where-can-i-find-and-install-the-dependencies-for-pygame
   En concreto, en máquinas con Debian y derivados hay que instalar:
   ```
   sudo apt-get install python-dev libsdl-image1.2-dev libsdl-mixer1.2-dev libsdl-ttf2.0-dev   libsdl1.2-dev libsmpeg-dev python-numpy subversion libportmidi-dev ffmpeg libswscale-dev libavformat-dev libavcodec-dev
   ```

5. Instalar thommy con `pip install thonny`.

6. Instalar xosview con `apt install xosview`.

7. Instalar epiphany con `apt install epiphany`.

8. Usar https://github.com/vicente-gonzalez-ruiz/YAPT/blob/master/workshops/programacion_python_ESO/README.md . como página de inicio de Firefox (Preferences -> Home -> Homepage and new windows -> Custom URL).
