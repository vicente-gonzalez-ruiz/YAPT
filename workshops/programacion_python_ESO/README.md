# Programación con Python para estudiantes de ESO

## ¿Por qué podría sernos útil saber programar?

Porque:

1. [Puede ser divertido](https://www.fluentu.com/blog/english-esp/wp-content/uploads/sites/33/2018/04/online-games-to-practice-english-e1522729897682.jpg).
2. [Puede ser útil](https://es.euronews.com/2020/06/08/superordenadores-contra-el-coronavirus-identifican-moleculas-que-bloquean-su-progresion).
3. [Puedes ganarte la vida con ello](https://www.revistagq.com/noticias/articulo/trabajos-mas-demandados-2020).

## ¿En qué vamos a programar?

Usaremos el lenguaje de programación [Python](https://www.python.org/)
por ser:
1. [Fácil de
   aprender](https://programadesdecero.com/lenguaje-programacion-aprender/)
   (básicamente, se diseñó con la idea de parecerse al lenguaje
   natural Inglés).
2. [Libre](https://empresas.blogthinkbig.com/las-5-razones-por-las-que-todo-el-mundo-quiere-aprender-python/)
   (no cuesta dinero usarlo, si no quieres ... hay distribuciones de
   Python creadas por empresas que te cobran principalmente por
   asesorarte en su uso), y además es
   [abierto](https://es.wikipedia.org/wiki/Software_de_c%C3%B3digo_abierto). Esto último es importante para muchas [empresas](https://www.muycanal.com/2020/02/19/las-empresas-prefieren-el-codigo-abierto-para-su-software-empresarial) y organizaciones ([CERN](https://home.cern/science/computing/open-source-open-science), [NASA](https://code.nasa.gov/)).
3. Uno de los pocos lenguajes de programación que se podría calificar
   como *democrático*, diseñado por la comunidad de Python para la
   comunidad de Python que es muy grande y lo [evoluciona
   constantemente](https://www.python.org/dev/peps/).
4. Un [lenguaje de propósito
   general](http://enciclopedia.us.es/index.php/Lenguaje_de_prop%C3%B3sito_general)
   (no está especializado en resolver ningún tipo de problema en
   concreto) y dispone de una [biblioteca de
   código](https://pypi.org/) enorme (con más de 250.000 paquetes), lo
   que hace que
   [prototipar](https://es.wikipedia.org/wiki/Modelo_de_prototipos)
   con Python sea fácil y rápido.
4. [Uno de los más demandados](http://pypl.github.io/PYPL.html),
   especialmente en el ámbito docente y científico (especialmente, en
   el campo de la [Inteligencia
   Artificial](https://es.wikipedia.org/wiki/Inteligencia_artificial)).

## ¿Sobre qué vamos a programar?

Vamos programar sobre un
[PC](https://es.wikipedia.org/wiki/Computadora_personal#:~:text=Una%20computadora%20personal%2C%20computador%20personal,las%20computadoras%20IBM%20PC%20compatibles.)
con [Linux](https://es.wikipedia.org/wiki/GNU/Linux), en concreto una
versión de Linux llamada [Xubuntu](https://xubuntu.org/), aunque
Python puede usarse [casi](https://www.python.org/download/other/) en
cualquier plataforma actual.

## ¿Qué vamos a programar?

Básicamente, vamos a diseñar e implementar 3 programas:

1. Un comprobador de [números primos](https://es.wikipedia.org/wiki/N%C3%BAmero_primo).
2. Un juego de adivinanza de [números naturales](https://es.wikipedia.org/wiki/N%C3%BAmero_natural).
2. Una versión personalizada del juego [Pong](https://en.wikipedia.org/wiki/Pong).

## Tecnicamente (desde el punto de vista de la programación) aprenderemos ...

1. A distinguir y reconocer las partes básicas de una [computadora](https://es.wikipedia.org/wiki/Computadora).
2. A comprender qué es un [lenguaje de programación](https://es.wikipedia.org/wiki/Lenguaje_de_programaci%C3%B3n).
3. A comprender qué es un [algoritmo](https://es.wikipedia.org/wiki/Algoritmo) y a implementarlos.
4. A distinguir entre lenguajes [compilados](https://es.wikipedia.org/wiki/Lenguaje_de_programaci%C3%B3n_compilado) e [interpretados](https://es.wikipedia.org/wiki/Int%C3%A9rprete_(inform%C3%A1tica)).
5. A interpretar qué es la [potencia de cómputo](https://en.wikipedia.org/wiki/Computer_performance).
6. A usar el [intérprete de Python](https://docs.python.org/3/tutorial/interpreter.html).
7. La [sintaxis básica de Python](https://www.w3schools.com/python/python_syntax.asp).
8. Algo sobre la [PLL (Python Standard Library)](https://docs.python.org/3/library/) y cómo usarla.
9. Algunos conceptos sobre [programación orientada a objetos](https://es.wikipedia.org/wiki/Programaci%C3%B3n_orientada_a_objetos).
10. Algunos conceptos básicos sobre programación de [vídeojuegos](https://es.wikipedia.org/wiki/Videojuego).

## Pero antes, una comparativa interesante

* [El coche más potente del mundo](https://www.autocasion.com/actualidad/pruebas/nuevo-lotus-evija-coche-mas-potente-mundo-fotos-info#:~:text=Con%202.000%20CV%20de%20potencia,presentado%20por%20el%20fabricante%20sueco.).
* [El ordenador más potente del mundo](https://computerhoy.com/reportajes/tecnologia/ibm-summit-superordenador-mas-potente-del-mundo-627963).
* [Evolucion de las computadoras y coches](https://www.muycomputer.com/2017/02/05/coches-evolucionado-ritmo-pc/).

## Otros links interesantes (... pero esto, para cuando estés aburrido)

* [La primera computadora (infobae)](https://www.infobae.com/america/tecno/2019/10/14/cual-fue-la-primera-computadora-de-la-historia/).
* [La primera generación de computadoras (wikipedia)](https://es.wikipedia.org/wiki/Primera_generaci%C3%B3n_de_computadoras).
* [El triunfo de los nerds (Wikipedia)](https://es.wikipedia.org/wiki/El_triunfo_de_los_nerds).
* [El triunfo de los nerds Cap 1/3](https://www.youtube.com/watch?v=6KgYRX-cNxA).
* [El triunfo de los nerds Cap 2/3](https://www.youtube.com/watch?v=87EFyQN_Q-E).
* [El triunfo de los nerds Cap 3/3](https://www.youtube.com/watch?v=Ofli7d0mtOU).
* [Nerds 2.0.1 - A Brief History of the Internet - Cap 1/2: Networking The Nerds](https://www.youtube.com/watch?v=L4D2nxQBmOM). [Aquí](http://forohistorico.coit.es/index.php/multimedia/videoteca/item/the-triumph-of-the-nerds-the-rise-of-accidental-empires) está con más calidad.
* [Nerds 2.0.1 - A Brief History of the Internet - Cap 2/2: Serving the Suits](https://www.youtube.com/watch?v=d0ya8DggDYs).
* [¿Cuál fue el primer videojuego, quién lo creó y por qué?](https://plarium.com/es/blog/el-primer-videojuego/).
* [Video Tennis For Two (1958)](https://www.youtube.com/watch?v=6PG2mdU_i8k), diseñado por [William Higinbotham](https://en.wikipedia.org/wiki/William_Higinbotham).
* [Pong en una Magnavox Odyssey (1972)](https://www.youtube.com/watch?v=jLGBtkKPj2U), la primera video-consola comercial.
* [Pong en una máquina arcade de Atari (1972)](https://www.youtube.com/watch?v=YmzH4E3x1_g).
* [Pong en una consola Super Pong de Atari (1976)](https://www.youtube.com/watch?v=9pSMU20bt2M).

## <a id="ejer_0"></a>Ejercicio 0: Di: "¡Hola Mundo!" en Python

Pues eso. Todos los programadores comienzan aprendiendo un lenguaje
nuevo implementando el "Hello World!". Para ello:

1. Abre un terminal y ejecuta:
   ```bash
   pyenv activate curso_python
   ```
   Esto sirve para usar una versión específica de Python (la 3.8.5,
   véase la sección de aprovisionamiento más abajo) y con sus propias
   bibliotecas, para no interferir así con el *ecosistema* de Python
   usado por el [sistema
   operativo](https://es.wikipedia.org/wiki/Sistema_operativo).

2. Ejecuta el [IDE (Integrated Development
   Environment)](https://en.wikipedia.org/wiki/Integrated_development_environment)
   que usaremos para programar y que se llama
   [Thonny](https://thonny.org/):
   
   ```bash
   thonny &
   ```
   
   El símbolo `&` indica que el comando `thonny` se va a ajecutar en
   [background](https://en.wikipedia.org/wiki/Background_process)
   dentro del [shell](https://en.wikipedia.org/wiki/Unix_shell).

3. Escribir el siguiente código:

   ```python
   print("¡Hola Mundo!")
   ```
   
   y almacenarlo en un archivo llamado `hello_world.py` (la extensión
   `py` indica que se trata de un módulo de Python (así es como se
   llaman los archivos en Python), aunque esto es irrelevante para el
   sistema operativo Linux).
   
4. Ejecutarlo. Esto lo podemos hacer de dos maneras diferentes:
   1. Escribiendo en el terminal (también llamado shell):
   
	  ```bash
	  python hello_world.py
	  ```
	  
   2. Pulsando el botón de *Run* (es verde y tiene un triángulo blanco
      dentro) de Thonny.

<!-- Primera parada técnica -->

## <a id="ejer_1"></a>Ejercicio 1: Compilación vs Interpretación
En el [Ejercicio 0](#ejer_0) hemos interpretado el módulo
`hello_world.py`. Para ello, hemos ejecutado el intérprete ( `python`)
y a éste le hemos pasado como argumento el nombre del módulo
(`hello_world.py`). Ahora vamos a ejecutar un programa escrito en el
lenguaje C, llamado
[`cpu_test.c`](https://raw.githubusercontent.com/vicente-gonzalez-ruiz/YAPT/master/workshops/programacion_python_ESO/cpu_test.c). Como
C es un lenguaje compilado, tendremos que compilar el programa antes
de ejecutarlo.

1. En un terminal ejecutar:
   ```bash
   gcc cpu_test.c -o cpu_test -lm
   ```
   
2. El comando anterior genera un archivo ejecutable llamado
   `cpu_test`. Para ejecutarlo, escribir:
   
   ```bash
   ./cpu_test 100000000
   ```
   
   donde el parámetro `100000000` es el número de operaciones en punto
   flotante (raíces cuadradas en nuestro ejemplo) que se van a
   realizar. Tras efectuarlas, el programa mostrará cuántas (en
   millones) se han ejecutado por segundo. Los archivos resultantes de
   una compilación ([código
   máquina](https://en.wikipedia.org/wiki/Machine_code) compilado) son
   dependientes de *la plataforma*
   ([CPU](https://en.wikipedia.org/wiki/Central_processing_unit) +
   [SO](https://es.wikipedia.org/wiki/Sistema_operativo)), pero corren
   más rápido que los interpretados porque la CPU ejecuta directamente
   el código máquina de nuestro programa. Cuando las aplicaciones se
   interpretan, la CPU en realidad ejecuta el intérprete, que es quien
   ejecuta las instrucciones del [código
   fuente](https://en.wikipedia.org/wiki/Source_code) del
   programa. Por contrapartida, los programas interpretados no tienen
   que compilarse y por tanto, no dependen de la plataforma (siempre y
   cuando [exista un intérprete para dicha
   plataforma](https://www.python.org/downloads/)).

## <a id="ejer_2"></a>Ejercicio 2: Averigua si un número natural N es primo

Los números primos son la base de la [criptografía asimétrica](https://es.wikipedia.org/wiki/Criptograf%C3%ADa_asim%C3%A9trica) (también llamados algoritmos criptográficos de clave pública) y son muy importantes para [*esconder* información digital](https://www.lasexta.com/tecnologia-tecnoxplora/ciencia/divulgacion/principios-basicos-encriptacion-entender-como-snowden-jugo-casa-blanca_2013082657fc98e90cf2fd8cc6b0d634.html), desarrollar [firmas](https://academy.binance.com/es/security/what-is-public-key-cryptography) y [monedas](https://es.cointelegraph.com/explained/what-is-asymmetric-cryptography) digitales, desarrollar algoritmos de [hashing](https://es.wikipedia.org/wiki/Tabla_hash), etc.

Un [número natural](https://es.wikipedia.org/wiki/N%C3%BAmero_natural)
N es primo si ninguna de las divisiones de N entre los enteros primos
menores sqrt(N) (la raíz cuadrada de N) divide a N de forma
exacta. Este algoritmo puede verse
[aquí](http://www.ceiploreto.es/sugerencias/ceibal/Primo_o_compuesto/cmo_saber_si_un_nmero_es_primo.html).

Por tanto, nuestro problema de averiguar si un número natural N es
primo o no (entonces, se dice que es compuesto) se puede dividir en 2
subproblemas:
1. Determinar la lista de los números primos menores o iguales que
   sqrt(N).
2. Dividir N entre todos los números P de dicha lista, y para cada uno
   de ellos comprobar:
   1. Si N es divisible entre P, entonces N es compuesto y debemos
      terminar el algoritmo.
3. Si hemos llegado hasta aquí en el algoritmo, entonces N es primo.

El paso número 1 es famoso desde hace más de 2000 años y se conoce
como [La Criba de
Erastótenes](https://es.wikipedia.org/wiki/Criba_de_Erat%C3%B3stenes). Recreando
lo que podemos encontrar en la Wikipedia, debemos:
1. Crear una lista con todos los números naturales superiores a 2
   (recuerda que el 1 divide a todos los números de forma exacta) y
   menores o iguales que sqrt(N). Esto se puede hacer en Python
   escribiendo:
   
   ```python
   primes = []
   for i in range(2, int(math.sqrt(N))+1):
	   primes.append(i)
   ```
   
2. Para cada número en la lista, comenzando por el 2, eliminaremos
   todos sus múltiplos en dicha lista:
   
   ```python
   for i in range(2, int(math.sqrt(N))+1):
	   if i in primes:
		   for j in range(i*2, int(math.sqrt(N))+1, i):
			   if j in primes:
				   primes.remove(j)
   ```

   En este punto, `primes` contiene la lista de todos los números
   naturales entre 2 y sqrt(N), y que son números primos.
   
Finalmente, sólo nos queda comprobar si alguno de los números de la
lista con la criba divide de forma exacta a N:

```python
N_is_prime = True
for i in primes:
    if N % i == 0:
        N_is_prime = False # porque i divide a N
        break
```

Una posible solución a este ejercicio puede se encuentra
[aquí](https://raw.githubusercontent.com/vicente-gonzalez-ruiz/YAPT/master/workshops/programacion_python_ESO/check_prime.py). Si
tienes curiosidad, la Wikipedia nos habla sobre [los números primos más
grandes
conocidos](https://es.wikipedia.org/wiki/Mayor_n%C3%BAmero_primo_conocido).

<!-- día 3 -->

## <a id="ejer_3"></a>Ejercicio 3: Bueno, juguemos un poco ahora ... y ¡averigua el número!
Dejemos ahora un poco de lado a las matemáticas y vamos programar juegos sencillos. El primero de ellos consiste en adivinar qué número, dentro de un rango, ha elegido de forma aleatoria la computadora. Básicamente, nuestro juego consistiría en:

1. Generar un número aleatorio (dentro de un rango que el jugador debe
conocer). Llamemos `random_number` a dicho número. Una forma de hacer
esto es usar el método
[`random.randrange()`](https://docs.python.org/3/library/random.html#random.randrange)
de la PSL.
2. Solicitar al jugador un número. Llamémoslo `guessed_number`. En la solición del [Ejercicio 2](#ejer_2) hay un ejemplo de cómo solicitar una entrada al programa desde el teclado.
3. Mientras el jugador no adivine el número (mientras `guessed_number != random_number`):
   1. Indicar al jugador si `random_number` es mayor o menor que
      `guessed_number`.
   2. Solicitar al jugador un nuevo `guessed_number`.

Si hemos sido inteligentes, deberíamos haber adivinado el número a lo sumo en `log_2(N)` (`= log(N)/log(2)`) intentos, que es la complejidad algorítmica de la [búsqueda binaria](https://en.wikipedia.org/wiki/Binary_search_algorithm).

Una posible solución a este ejercicio puede
encuentrarse
[aquí](https://raw.githubusercontent.com/vicente-gonzalez-ruiz/YAPT/master/workshops/programacion_python_ESO/guess_the_number.py). Otra implementación podría ser [esta](https://github.com/grantjenks/free-python-games/blob/master/freegames/guess.py), que es parte del paquete [freegames](https://pypi.python.org/pypi/freegames).

## <a id="ejer_4"></a>Ejercicio 4: Crear una ventana vacía (empty screen) usando Pygame
Nuestra versión de Pong se va a apoyar en el uso del paquete
[Pygame](https://www.pygame.org/news), que ofrece una
[API](https://en.wikipedia.org/wiki/API) para programar videojuegos en
Python. Lo primero que vamos a hacer es aprender a abrir (y cerrar) un
[display](https://www.pygame.org/docs/ref/display.html) (una ventana
(window) o una pantalla (screen), dependiendo del sistema gráfico
porporcionado por el
[SO](https://es.wikipedia.org/wiki/Sistema_operativo)) en el que nos
encontremos programando. Tendremos que:

1. Importar Pygame (escribir la instrucción de Python `import pygame`).
2. Inicializar Pygame (usar el método [`pygame.init()`](https://www.pygame.org/docs/ref/pygame.html#pygame.init)).
3. Crear una ventana (usar [`pygame.display.set_mode()`](https://www.pygame.org/docs/ref/display.html#pygame.display.set_mode)).
4. Darle un título a la ventana (usar
   [`pygame.display.set_caption()`](https://www.pygame.org/docs/ref/display.html#pygame.display.set_caption)).
5. Esperar a que el usuario cierre la ventana (cosa que ocurre,
   cuando [`pygame.event.wait().type`](https://www.pygame.org/docs/ref/event.html#pygame.event.wait) retorna un evento del tipo
   [`pygame.QUIT`](https://www.pygame.org/docs/ref/event.html)).
6. Cerrar Pygame (usar [`pygame.quit()`](https://www.pygame.org/docs/ref/pygame.html#pygame.quit)).
Una posible solución está disponible [aquí](https://raw.githubusercontent.com/vicente-gonzalez-ruiz/YAPT/master/workshops/programacion_python_ESO/empty_display_v0.py).
   
Gran cantidad de información sobre cómo programar juegos usando Pygame
puede encontrarse en [Programar Juegos Arcade con Python y
Pygame](http://programarcadegames.com/).

## <a id="ejer_5"></a>Ejercicio 5: Pintar un par de puntos
Además de aprender cómo dibujar puntos, el objetivo de este ejercicio
es averiguar cómo se distribuyen las coordenadas en un display de
Pygame.
1. Importar Pygame (ídem [Ejercicio 4](#ejer_4)).
2. Inicializar Pygame (ídem [Ejercicio 4](#ejer_4)).
3. Crear una pantalla (ídem [Ejercicio 4](#ejer_4)).
4. Darle un título a la pantalla (ídem [Ejercicio 4](#ejer_4)).
5. Pintar un punto blanco en la coordenadas (x=1, y=1) (usar [`pygame.screen.set_at(https://www.pygame.org/docs/ref/surface.html#pygame.Surface.set_at)`]()).
6. Pintar un punto verde en (x=10, y=100).
7. Esperar a que el usuario cierre la pantalla (ídem [Ejercicio 4](#ejer_4)).
8. Cerrar Pygame (ídem [Ejercicio 4](#ejer_4)).

Una posible solución es [esta](https://raw.githubusercontent.com/vicente-gonzalez-ruiz/YAPT/master/workshops/programacion_python_ESO/plot_pixels_v0.py).

## ¡Odio tener código duplicado!
Si comparamos el código (fuente) desarrollado para los Ejercicios
[4](#ejer_4) y [5](#ejer_5), apreciaremos que son casi idénticos. Esto
puede ser interesante cuando queremos que ambos módulos sean
completamente independientes, de manera que si modificamos uno, el
comportamiento del otro no se vea afectado. Sin embargo, en general
tener código duplicado no es una buena idea porque dificulta su
mantenimiento. Por ejemplo, si nos damos cuenta de que en la solución
del [Ejercicio 4](#ejer_4) hemos cometido un error, casi seguro que
dicho error está también en la solución del [Ejercicio 5](#ejer_5),
porque reutiliza mucho del código. Lo ideal sería que las
implementaciones de ambos ejercicios compartieran el código que tienen
en común.

La solución más frecuente y elegante para resolver la duplicación de
código pasa por utilizar el [Paradigma de Programación Orientada a
Objetos](https://es.wikipedia.org/wiki/Programaci%C3%B3n_orientada_a_objetos),
o en inglés,
[OOP](https://en.wikipedia.org/wiki/Object-oriented_programming).

## Pensando en objetos
La OOP ayuda a organizar el código fuente de tus programas y a hacer
que éstos se puedan mantener (por ejemplo, encontrar
[bugs](https://es.wikipedia.org/wiki/Error_de_software) (bichos,
aunque todo el mundo usa la palabra inglesa), a lo que también se
llama
[depurar](https://es.wikipedia.org/wiki/Depuraci%C3%B3n_de_programas),
[debugging](https://en.wikipedia.org/wiki/Debugging) en inglés) más
fácilmente. La idea es organizar el código en clases (así se llaman
estructuras de datos (llamadas atributos en el contexto de la OOP) y
funciones (llamadas métodos en el contexto de la OOP) asociadas)), y
utilizar la
[herencia](https://es.wikipedia.org/wiki/Herencia_(inform%C3%A1tica))
para evitar reimplementar lo ya implementado (las clases heredan el
comportamiento de las clases *ancestro*, también llamadas clases
*base*, clases *padre* (cuando la herencia es directa), ...). A las
instancias de las clases se les llama *objetos*, y en Python [casi
todo lo que manejamos son
objetos](https://docs.python.org/3/reference/datamodel.html). Por
ejemplo, para implementar la Criba de Erastótenes del [Ejercicio
2](#ejer_2) hemos instanciado un objeto de clase lista (`primes`).

Veamos un ejemplo de diseño de clases. Supongamos que queremos
trabajar con gatos y perros, y queremos que cuando un perro o un gato
sean instanciados, aparezca un mensaje que indique tal acción, y
cuando sean borrados de la memoria de la computadora aparezca otro
mensaje indicando también dicha acción. Usando la OOP, podemos definir
3 clases:
[`Animal`](https://raw.githubusercontent.com/vicente-gonzalez-ruiz/YAPT/master/workshops/programacion_python_ESO/animal.py)
(las clases en Python suelen comenzar con una letra en mayúscula),
[`Cat`](https://raw.githubusercontent.com/vicente-gonzalez-ruiz/YAPT/master/workshops/programacion_python_ESO/cat.py)
y
[`Dog`](https://raw.githubusercontent.com/vicente-gonzalez-ruiz/YAPT/master/workshops/programacion_python_ESO/dog.py),
usando la siguiente relación:

```
    +--------+
    | Animal |
    +---+----+
        |
   +----+----+
   |         |
   v         v
+--+--+   +--+--+
| Cat |   | Dog |
+-----+   +-----+
```

indicando que un objeto de la clase `Cat`y otro de la clase `Dog` son
ambos animales, y por tanto, comparten el comportamiento definido en la
clase `Animal`. Podemos comprobar esto ejecutando en el terminal:

```bash
python animal.py

```
Luego ejecutando:

```bash
python dog.py

```

Y finalmente, ejecutando:

```bash
python cat.py

```

Si nos fijamos bien en los mensajes que aparecen en el terminal,
cuando desde los módulos `cat.py` y `dog.py` se hace un `import
animal`, el código que hay en el bloque del `__main__` no se ejecuta.

## <a id="ejer_6"></a>Ejercicio 6: Reimplementamos los Ejercicios [4](#ejer_4) y [5](#ejer_5) usando la OOP
Vamos a definir 2 clases en 2 módulos (archivos) diferentes:
1. Una clase padre, llamada `EmptyDisplay`, en la que vamos a definir
   3 métodos:

   1. El constructor `__init__(self, width, caption)`, en el que
      crearemos un display vacío. Entre paréntesis hemos representado
      sus parámetros:

	  1. `self`, que [representa los atributos que de forma dinámica
         son
         creados](https://medium.com/quick-code/understanding-self-in-python-a3704319e5f0).
		 
	  2. `width`, que indica el ancho de la ventana, en pixels.
	  
	  3. `height`, que indica el alto de la ventana, en pixels.
	  
	  4. `caption`, con el nombre de la ventana.
	  
	  Todos los constructures de clase en Python tienen por nombre
	  `__init__`.
  
   2. El destructor `__del__(self)`, en el que cerraremos el
      display. Nótese que el primer parámetro de todos los métodos de
      una clase debe ser `self` (que no es más que una convención, en
      realidad podría usarse cuanquier otro nombre para este
      parámetro). `__del__` es una palabra reservada para el
      destructor.

   3. Un método llamado `run(self)`, que implementará la lógica
      necesaria para esperar a que se cierre la ventana. `run` no es
      una palbra reservada (el método podría tener cualquier otro
      nombre).

   4. Un método denominado `get_event(self)`, que retorna un evento
      (por ejemplo, el cierre de la ventana). El método `run(self)`
      llamará a `get_event(self)`.
   
2. Una clase hija que hereda de la clase `EmptyDisplay`, llamada
   `PlotPlixels`, que *sobreescribirá* el método `EmptyDisplay.run()`
   con la loǵica necesaria para pintar los dos pixels pixels y luego,
   esperar a que se cierre la ventana.

Una posible solución está disponible en
[`empty_display.py`](https://github.com/vicente-gonzalez-ruiz/YAPT/blob/master/workshops/programacion_python_ESO/empty_display.py)
y
[`plot_pixels.py`](https://github.com/vicente-gonzalez-ruiz/YAPT/blob/master/workshops/programacion_python_ESO/plot_pixels.py). Nótese
que además hará falta el módulo `colors.py` que debe estar dentro de
una carpeta llamada `lib` (crear la carpeta escribiendo en el terminal
`mkdir lib` y mover `colors.py` dentro con `mv colors.py lib`). En
este módulo han sido definidos algunos colores básicos. La razón por
la que `colors.py` se colocan dentro de la carpeta `lib` es porque si
por casualidad hubiera algún paquete en la
[PSL](https://docs.python.org/3/library/) o en
[PyPI](https://pypi.org/) llamado también `colors`, evitaríamos que
nuestro `colors` enmascarara al paquete "estándar".

## <a id="ejer_7"></a>Ejercicio 7: Pintar un rectángulo
La pelota de nuestro Pong va a ser un cuadrado. Aprendamos a dibujar rectángulos:
1. Crear una clase llamada `DrawRectangle` que herede de la clase `EmptyDisplay`.
2. Sobreescribir el método `EmptyDisplay.run()` para que se pinte un
   rectángulo y se cierre la ventana. Para dibujar un rectángulo podemos usar el método [`pygame.draw.rec()`](https://www.pygame.org/docs/ref/draw.html#pygame.draw.rect).
Una posible solución puede encontrarse en [`draw_rectangle.py`](https://github.com/vicente-gonzalez-ruiz/YAPT/blob/master/workshops/programacion_python_ESO/draw_rectangle.py).

## <a id="ejer_8"></a>Ejercicio 8: Rebota el rectángulo
En nuestro Pong la pelota rebotará en los límites del
display. Hagamos, por tanto, que el rectángulo se mueva en diagonal, a
velocidad constante a razón de un pixel en horizontal y otro en
vertical por cada frame presentado, rebotando en las paredes de la
ventana.
1. Crear una clase llamada `BouncingBall` que herede de la clase
   `EmptyDisplay`.
2. Sobreescribir el método `EmptyDisplay.run()` para que pinte la
   pelota (un cuadrado blanco). En este método tendremos que controlar
   la posición de la pelota, y en lugar de usar `pygame.event.wait()`
   para detener la ejecución de la aplicación hasta que no se produzca
   un nuevo evento, usaremos el método
   `[pygame.event.get()`](https://www.pygame.org/docs/ref/event.html#pygame.event.get)
   que lo que hace básicamente es sacar de una cola de eventos el
   siguiente disponible y retornar inmediatamente, tanto si la cola
   tiene elementos como si está vacía. A este último tipo de
   instrucciones (bueno, en realidad un método en nuestro caso) se les
   llama *no bloqueantes*, porque retornan de su llamada
   rápidamente. En contrapartida, `pygame.event.wait()` es un método
   bloqueante. Si queremos refrescar el display de nuestro juego,
   `pygame.event.get()` es la solución, y debe usarse así:
   
   ```python
   for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
   ```

Una posible solución a este ejercicio está disponible en [`bouncing_ball.py`](https://github.com/vicente-gonzalez-ruiz/YAPT/blob/master/workshops/programacion_python_ESO/bouncing_ball.py).

## <a id="ejer_9"></a>Ejercicio 9: Crea la clase `EmptyDisplayPoll`
La clase `EmptyDisplay` espera (quedándose bloqueada en la instrucción
`pygame.event.wait()`) a recibir el evento `pygame.QUIT` que indica
que el display ha sido cerrado. Sin embargo, en la inmensa mayoría de
los juegos el método que vamos a usar es el método
`pygame.event.get()`. Para resolver este problema tenemos dos
opciones:

1. La primera es utilizar el método `pygame.event.get()` en todos los
   métodos `run()` de nuestras clases, reescribiendo una y otra vez el
   mismo código.
   
2. La segunda es modificar la clase `EmptyDisplay` añadiendo un nuevo
   método llamado `poll_event()` (que usa `pygame.event.wait()`), que
   para que en una clase hija llamada `EmptyDisplayPoll`
   sobreescribamos el método `poll_event()` (usando la clase
   `pygame.event.get()`). Así tendremos menos código en las clases
   herederas como `BouncingBall`.

## Ejercicio: Añadir sonido.

En nuestro camino hacia implementar un [clone de Pong](https://sites.google.com/site/thepythonpongtutorial/home).


## Ejercicio: Usar sprites

## Ejercicio: Reutilizar el código de la pantalla vacía para pintar puntos
1. Distribuir el código del Ejercicio 1 en métodos (de una clase
   llamada `Screen`; llamar al fichero que la contiene `screen.py`),
   de forma que la clase creada para el Ejercicio 2 pueda reutilizar:
   (1) la parte de código que crea la ventana, y (2) la parte de
   código que cierra la ventana y Pygame.

```
<---------------------- screen_width ----------------------->
+-----------------------------------------------------------+ ^
|    +----------+                                           | |
| <- | computer | ->                                        | |
|    +----------+                                           | |
|                                                           | s
|                                                           | c
|                                                           | r
|                                                           | e
|                                                           | e
|                                                           | n
| - - - - - - - - - - - - - - - - - - - - - - - - - - - - - | _
|                                                           | h
|                                                           | e
|                * <- the ball                              | i
|                                                           | g
|                                                           | h
|                                                           | t
|                 +----------+                              | |
|              <- |  human   | ->                           | |
|                 +----------+                              | |
+-----------------------------------------------------------+ v
```

```
main():
  computer_points_counter = 0
  human_points_counter = 0
  while (computer_points_counter < 10) and (humman_points_counter < 10):
    if ball_coordinate_y < 0:
	  human_points_counter = human_points_counter + 1
	else if ball_coordinate_y > screen_height:
	  computer_points_counter = computer_points_counter + 1
```

## Open a window

1. [¿Qué es un lenguaje de programación?]().
2. [¿Qué es Python?]().
3. [Sistemas donde corre Python]()-
4. [Un poco de Linux y su consola de comandos]().
5. [Instalación de Python en Linux]().
6. [Hello World en Python](http://localhost:8888/notebooks/YAPT/03-hello_world.ipynb#Hello-world!).
7. [¿Qué es PyGame?](http://localhost:8888/notebooks/YAPT/04-structuring_code.ipynb#Structuring-code).

7. [PacMan](https://github.com/grantjenks/free-python-games/blob/master/freegames/pacman.py) from [Free Python Games](http://www.grantjenks.com/docs/freegames/). See [https://pypi.python.org/pypi/freegames](https://pypi.python.org/pypi/freegames) at [The Python Package Index](https://pypi.python.org/pypi). Extra info at [Using Turtle graphics: a Tkinter based turtle graphics module for Python](http://localhost:8888/notebooks/YAPT/A3-Turtle.ipynb#Using-Turtle-graphics:-a-Tkinter-based-turtle-graphics-module-for-Python).
8. [I/O](http://localhost:8888/notebooks/YAPT/18-IO.ipynb).

## Apéndice A: Comandos básicos del terminal

* `cd` (change directory): permite moverse por el sistema de
  ficheros. Ejemplos:
  ```bash
  cd Downloads  # Entra en el directorio "Downloads"
  cd            # Retorna al "home directory"
  cd ..         # Sube al directorio superior en el sistema de ficheros
  ```

* `ls` (list): muestra el contenido de un directorio. Ejemplos:
  ```bash
  ls            # Listado simple
  ls -l         # Listado largo
  ls -a         # Mostrar ficheros "ocultos"
  ls -R         # Listado recursivo
  ls -lR        # Listado largo y recursivo
  ```
  
* `cat`: muestra el contenido de un archivo. Ejemplos:
  ```bash
  cat mi_fichero
  ```

* `mkdir` (make directory): crea un directorio. Ejemplo:
  ```bash
  mkdir lib
  ```

* `cp` (copy): copia un archivo/directorio. Ejemplos:
  ```bash
  cp hello_world.py copia_de_hello_world.py
  cp -r lib /tmp  # Copia el directorio "lib" al directorio "/tmp"
  ```

* `mv` (move): mueve un archivo/directorio o renobra un
  archivo/directorio. Ejemplos:
  ```bash
  mv hello_world.py hola_mundo.py  # Renombra un archivo
  mv lib biblioteca                # Renombra un directorio
  ```

* `rm` (remove): borra un archivo/directorio PARA SIEMPRE. Ejemplos:
  ```bash
  rm hola_mundo.py  # Elimina el archivo "hola_muldo.py" del sistema de ficheros
  rm -r lib         # Borra el directorio "lib", junto co todos sus contenidos
  ```

* `rmdir` (remove directory): borra un directorio vacío PARA SIEMPRE. Ejemplo:
  ```bash
  rm lib  # Borra el directorio vacío "lib"
  ```

## Apéndice B: Aprovisionamiento
1. Instalar [Xubuntu 20.04 (Focal
   Fossa)](https://xubuntu.org/download/) en un pendrive de al menos 8
   GB. Xubuntu recién instalado ocupa aproximadamente 5 GB.
	* En [Windows](https://ubuntu.com/tutorials/create-a-usb-stick-on-windows#1-overview).
	* En [Ubuntu](https://ubuntu.com/tutorials/create-a-usb-stick-on-ubuntu#1-overview).
	* En [OSX](https://ubuntu.com/tutorials/create-a-usb-stick-on-macos#1-overview).
	* En [Linux](https://askubuntu.com/questions/372607/how-to-create-a-bootable-ubuntu-usb-flash-drive-from-terminal).
    * Indicar que se quiere actualizar Xubuntu mientras se instala (si
      hay conexión a Internet) y que se desea instalar software de
      terceros (propietario).
	* Es preferible seleccionar English como idioma, pero elegir el
      teclado correspondiente (seguramente Español).
    * En *Installation type* hay que seleccionar *Something else*,
	  particionar el pendrive en 3 particiones: (1) /dev/sd<disk>1 de
	  tipo EFI con 512 MB (aproximadamente), (2) /dev/sd<disk>2 de
	  tipo swap con 8 GB (8192 MB, aproximadamente y dependiendo del
	  tamaño del pendrive), y (3) /dev/sd<disk>3 de tipo ext4, con el
	  resto del pendrive, y para montarse en /, que debería ser
	  formateada. Finalmente, no olvidar indicar que el boot loader
	  debe instalarse también en el pendrive /dev/sd<disk>, donde
	  <disk> es una letra, seguramente "b" o "c", dependiendo del
	  número de discos que tengamos instalados en nuestro
	  ordenador. Ojo de no seleccionar, por ejemplo, /dev/sda, porque
	  estaríamos particionando y formateando el primer disco de
	  nuestro ordenador. Nota: es posible que aparezcan huecos
	  pequeños con espacio libre al comienzo de espacio de
	  almacenamiento del pendrive, al final y entre las
	  particiones. Esto no importa y es irremediable.
    * Usuario: "ion".
	* Hostname: "sirius".
    * Contraseña: "curso".

2. [Instalar (usando
   pyenv)](https://github.com/vicente-gonzalez-ruiz/YAPT/blob/master/01-hello_world/02-installation.ipynb)
   la versión 3.8.5 de CPython, y crear un entorno virtual llamado
   "curso_python".

3. Activar el VE `curso_python` escribiendo:
   ```bash
   pyenv activate curso_python
   ```
   en `.bashrc`.

4. Instalar pygame usando pip dentro del VE. Ver
   https://stackoverflow.com/questions/7652385/where-can-i-find-and-install-the-dependencies-for-pygame
   En concreto, en máquinas con Debian y derivados hay que instalar:
   ```
   sudo apt-get install python-dev libsdl-image1.2-dev libsdl-mixer1.2-dev libsdl-ttf2.0-dev   libsdl1.2-dev libsmpeg-dev python-numpy subversion libportmidi-dev ffmpeg libswscale-dev libavformat-dev libavcodec-dev
   ```

5. Instalar thommy con `pip install thonny`.

6. Instalar xosview con `apt install xosview`.

7. Instalar epiphany con `apt install epiphany`.

8. Usar https://github.com/vicente-gonzalez-ruiz/YAPT/blob/master/workshops/programacion_python_ESO/README.md . como página de inicio de Firefox (Preferences -> Home -> Homepage and new windows -> Custom URL).
